# frozen_string_literal: true

require "appydays/loggable"
require "csv"
require "digest"
require "fileutils"
require "icalendar"

class PpsFoodFeed
  class IcsConverter
    include Appydays::Loggable

    def run
      FileUtils.mkdir_p(PpsFoodFeed::FEEDS_DIR)
      @meta = PpsFoodFeed::Meta.load
      groups = PpsFoodFeed::CSV_DIR.children.group_by { |f| PpsFoodFeed.parse_menu_name_month_hash(f)[0] }
      groups.each do |menu, csv_files|
        self.create_ical(menu, csv_files)
      end
      @meta.save
    end

    def create_ical(menu_name, csv_files)
      menu = PpsFoodFeed::Menus.get(menu_name)
      cal = Icalendar::Calendar.new
      cal.prodid = "-//#{menu_name}//#{PpsFoodFeed::HOMEPAGE_HOST} #{PpsFoodFeed::VERSION}//EN"
      cal.append_custom_property("X-WR-CALNAME", menu_name)
      cal.publish
      csv_files.each do |csv_file|
        csv_file = csv_file.to_s
        _, menu_month, hash = PpsFoodFeed.parse_menu_name_month_hash(csv_file)
        # Only use the latest CSV for the latest hash.
        # Do NOT use earlier CSVs since we don't different meals for the same day.
        if @meta.get(menu_name, menu_month, :latest_hash) != hash
          self.logger.debug("skipping_obsolete_csv", csv_file:)
          next
        end
        self.logger.debug("parsing_csv_to_ics", csv_file:)
        CSV.foreach(csv_file, headers: true, header_converters: :symbol, converters: :all) do |row|
          row = row.to_h
          # Make sure the LLM didn't emit invalid headers.
          month = row.fetch(:month)
          year = row.fetch(:year)
          # Sometimes the LLM uses day_of_month as asked, sometimes day, try both.
          day_of_month = row[:day_of_month] || row[:day] or
            raise KeyError, "row must contain :day_of_month or :day: #{row}"
          dstr = "#{month} #{day_of_month} #{year}"
          rubydate = Date.parse(dstr)
          d = Icalendar::Values::Date.new(rubydate)
          lastmod = Time.parse(@meta.get(menu_name, menu_month, :fetched_at))
          cal.event do |e|
            e.uid = self.uid(menu_name, menu_month, row)
            e.dtstart = d
            e.dtend = d
            e.last_modified = lastmod
            e.dtstamp = lastmod
            e.summary = self.summary(menu, row)
            e.description = self.description(menu, menu_name, menu_month, row)
          end
        end
      end
      cal.events.sort_by! { |e| [e.dtstart, e.summary, e.uid] }
      ical_filename = self.ical_filename(menu_name)
      @meta.set(menu_name, "_", :ical_filename, ical_filename)
      File.write(PpsFoodFeed::FEEDS_DIR.join(ical_filename), cal.to_ical)
      self.logger.info("write_ics", menu: menu_name, events: cal.events.count)
    end

    def uid(menu_name, menu_month, row)
      h = Digest::MD5.new
      h << menu_name
      h << menu_month
      h << JSON.generate(row)
      return h.hexdigest
    end

    def summary(menu, row)
      mc = menu.meal_columns.map(&:to_sym)
      title = mc.size == 1 ? row.fetch(mc.first) : mc.map { |c| row.fetch(c) }.join(", ")
      title += " (Early Release)" if row.fetch(:early_release)
      return title
    end

    def description(menu, menu_name, menu_month, row)
      mc = menu.meal_columns.map(&:to_sym)
      if mc.size == 1
        d = "Today's meal is: #{row.fetch(mc.first)}"
      else
        parts = mc.map { |c| "#{self.titleize(c)}: #{row.fetch(c)}" }.join("\n")
        d = "Served today:\n#{parts}"
      end
      url = @meta.get(menu_name, menu_month, :url)
      d += "\n\nTo see this month's menu, go to <a href=\"#{url}\">#{menu_month} - #{menu_name}</a>"
      d += "\n\nFeed generated by #{PpsFoodFeed::HOMEPAGE}. To report a problem, email #{PpsFoodFeed::AUTHOR}"
      return d
    end

    def titleize(s)
      return s[0].upcase + s[1..]
    end

    def ical_filename(menu_name)
      n = menu_name.downcase
      n = n.gsub("(", "").gsub(")", "").gsub(", ", "_")
      n = n.gsub(" ", "_")
      return n + ".ics"
    end
  end
end
